<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Run Raider — Final</title>
<style>
  :root{
    --bg1:#04040a; --bg2:#0b0b12; --neon:#00d7ff; --danger:#ff6b6b; --muted:#9aa3b2;
  }
  html,body{ height:100%; margin:0; background:linear-gradient(180deg,var(--bg1),var(--bg2)); color:#dfe7ef; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; }
  canvas{ display:block; width:100vw; height:100vh; }
  #ui{ position:absolute; inset:0; pointer-events:none; }
  .panel{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); border-radius:12px; padding:12px; box-shadow:0 8px 30px rgba(0,0,0,0.6); color:#e6eef6; }
  .center{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:auto; }
  .menuBox{ width:880px; max-width:96%; text-align:center; gap:8px; display:flex; flex-direction:column; align-items:center; }
  h1{ margin:0; font-size:34px; color:#fff; text-shadow:0 6px 30px rgba(0,0,0,0.6); }
  p.lead{ margin:0; color:var(--muted); font-size:13px; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
  button.btn{ pointer-events:auto; border:0; padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer; background:linear-gradient(180deg,#0ff9ff10,#00d7ff14); color:var(--neon); border:1px solid rgba(0,215,255,0.06); }
  button.btn.alt{ background:linear-gradient(180deg,#ff6b6b10,#ff6b6b12); color:var(--danger); border:1px solid rgba(255,107,107,0.06); }
  button.btn.ghost{ background:transparent; color:var(--muted); border:1px dashed rgba(255,255,255,0.04); }
  #hud{ position:absolute; left:16px; top:12px; display:flex; gap:10px; align-items:center; pointer-events:none; }
  .chip{ background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); font-weight:700; font-size:13px; color:#dfe7ef; }
  #bigScore{ position:absolute; left:50%; transform:translateX(-50%); top:12px; pointer-events:none; background:rgba(255,255,255,0.02); padding:8px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.03); font-weight:800; font-size:18px; }
  #controls{ position:absolute; bottom:12px; left:12px; pointer-events:none; background:rgba(255,255,255,0.02); border-radius:10px; padding:8px; border:1px solid rgba(255,255,255,0.02); color:var(--muted); font-size:13px; }
  #shopGrid{ display:grid; grid-template-columns: repeat(auto-fit,minmax(140px,1fr)); gap:10px; width:760px; max-width:94%; }
  .skinCard{ background:rgba(255,255,255,0.02); padding:10px; border-radius:10px; display:flex; flex-direction:column; gap:8px; align-items:center; pointer-events:auto; border:1px solid rgba(255,255,255,0.02); }
  .skinPreview{ width:68px; height:86px; border-radius:8px; display:flex; align-items:center; justify-content:center; font-weight:800; box-shadow: 0 8px 18px rgba(0,0,0,0.6); color:#101218; }
  #leaderboardList { text-align:left; margin-top:8px; font-size:14px; color:var(--muted); width:360px; }
  @media (max-width:720px){ h1{ font-size:26px } .menuBox{ padding:10px } #shopGrid{ grid-template-columns:repeat(2,1fr) } #leaderboardList { width:100%; } }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
  <div id="hud">
    <div class="chip" id="coinsChip">Coins: 0</div>
    <div class="chip" id="powerChip">Power: —</div>
  </div>

  <div id="bigScore">RUN RAIDER — Score: <span id="scoreVal">0</span></div>

  <!-- Menu -->
  <div id="menu" class="center">
    <div class="menuBox panel">
      <h1>RUN RAIDER — Final</h1>
      <p class="lead">Only saws & spikes now. Faster player movement. Slower scoring. Top-5 local leaderboard included.</p>
      <div class="row">
        <button id="startBtn" class="btn">Start (Space)</button>
        <button id="shopBtn" class="btn">Shop</button>
        <button id="howBtn" class="btn ghost">How to Play</button>
        <button id="resetBtn" class="btn alt">Reset Save</button>
      </div>

      <div style="display:flex; gap:16px; margin-top:8px; align-items:center; flex-wrap:wrap; justify-content:center;">
        <div style="text-align:center; color:var(--muted)">High Score<br><strong id="highScore">0</strong></div>
        <div style="text-align:center; color:var(--muted)">Total Coins<br><strong id="savedCoins">0</strong></div>
        <div id="leaderboardList" class="panel" style="padding:8px;">
          <strong style="color:#fff">Local Leaderboard (Top 5)</strong>
          <div id="leaderboardEntries" style="margin-top:8px;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- How to play -->
  <div id="how" class="center" style="display:none; pointer-events:auto;">
    <div class="panel menuBox">
      <h1>How to Play</h1>
      <p class="lead">Space=jump (double-jump if available) • Down/S=slide • Avoid saws & spikes — they are telegraphed and spaced fairly. Collect power-ups (shield, magnet, double-jump) and coins.</p>
      <div class="row"><button id="howBack" class="btn">Back</button></div>
    </div>
  </div>

  <!-- Shop -->
  <div id="shop" class="center" style="display:none; pointer-events:auto;">
    <div class="panel menuBox">
      <h1>Shop — Dark Skins & Perks</h1>
      <p class="lead">Skins match the dark theme. Buy permanent perks (double-jump/magnet/shield) to have them every run.</p>
      <div id="shopGrid"></div>
      <div class="row" style="margin-top:8px;"><button id="shopBack" class="btn">Close</button></div>
    </div>
  </div>

  <!-- Pause -->
  <div id="pause" class="center" style="display:none; pointer-events:auto;">
    <div class="panel menuBox">
      <h1>Paused</h1>
      <p class="lead">P to resume • R to restart.</p>
      <div class="row"><button id="resumeBtn" class="btn">Resume (P)</button><button id="restartBtn" class="btn alt">Restart (R)</button></div>
    </div>
  </div>

  <!-- Game Over with leaderboard save -->
  <div id="gameOver" class="center" style="display:none; pointer-events:auto;">
    <div class="panel menuBox">
      <h1>Run Over</h1>
      <p class="lead">Score <strong id="finalScore">0</strong> • Coins collected <strong id="finalCoins">0</strong></p>
      <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
        <input id="playerName" placeholder="Enter name (max 12)" maxlength="12" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.05);background:transparent;color:#fff"/>
        <button id="saveScoreBtn" class="btn">Save Score</button>
      </div>
      <div class="row" style="margin-top:10px;"><button id="tryBtn" class="btn">Try Again</button><button id="menuBtn" class="btn ghost">Back to Menu</button></div>
      <div style="width:100%; margin-top:12px;">
        <strong style="color:#fff">Leaderboard (Top 5)</strong>
        <div id="gameOverLeaderboard" style="margin-top:8px; color:var(--muted)"></div>
      </div>
    </div>
  </div>

  <div id="controls" class="chip">Space=Jump • Down/S=Slide • P=Pause • R=Restart</div>
</div>

<script>
/* Run Raider — final adjustments:
   - Only saw and spike obstacles
   - Faster, snappier player (jump power & feel)
   - Local Top-5 leaderboard saved in localStorage
   - Score growth slowed down (score per distance reduced)
   - Shop, skins & perks preserved
*/

// Canvas setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth, H = canvas.height = innerHeight;
window.addEventListener('resize', ()=> { W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

// CONFIG: tuned for faster player feel but slower scoring
const CONFIG = {
  gravity: 0.48,          // slightly lower gravity for floaty but snappy jumps
  jumpPower: 13.6,        // stronger jump for faster feel
  baseSpeed: 3.6,         // slightly faster world scroll (player feels quicker)
  speedRamp: 0.00045,     // very gentle increase per frame
  slideDuration: 520,
  coinValue: 1,
  scorePerPx: 0.09        // <--- lower (was higher), reduces score growth speed
};

// power-up durations
const POWERUP_DUR = { shield:4500, magnet:5000, doublejump:7500 };

// Skins & Perks arrays (dark theme)
const SKINS = [
  { id:'raider', name:'Raider', color:'#2ee8ff', accent:'#00bcd4', price:0 },
  { id:'onyx', name:'Onyx Raider', color:'#111217', accent:'#9fb6ff', price:45 },
  { id:'ember', name:'Ember Wraith', color:'#ff6b6b', accent:'#ff9b9b', price:95 },
  { id:'neon', name:'Neon Revenant', color:'#8affb3', accent:'#10b364', price:155 },
  { id:'void', name:'Void Shade', color:'#bdb7ff', accent:'#6a5fff', price:260 }
];
const PERKS = [
  { id:'perk_doublejump', name:'Permanent Double-Jump', price:160, key:'perk_doublejump' },
  { id:'perk_magnet', name:'Permanent Magnet', price:140, key:'perk_magnet' },
  { id:'perk_shield', name:'Permanent Shield', price:190, key:'perk_shield' }
];

const SAVE_KEY = 'run_raider_final_save';
const LB_KEY = 'run_raider_final_leaderboard';

// Save structure
function loadSave(){
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return { highScore:0, totalCoins:0, ownedSkins:['raider'], equipped:'raider', perks:{} };
    const p = JSON.parse(raw);
    return {
      highScore: p.highScore || 0,
      totalCoins: p.totalCoins || 0,
      ownedSkins: Array.isArray(p.ownedSkins) ? p.ownedSkins : ['raider'],
      equipped: p.equipped || 'raider',
      perks: p.perks || {}
    };
  } catch { return { highScore:0, totalCoins:0, ownedSkins:['raider'], equipped:'raider', perks:{} }; }
}
function saveGame(){ localStorage.setItem(SAVE_KEY, JSON.stringify(save)); }

let save = loadSave();

/* Leaderboard utilities (local top 5) */
function loadLeaderboard(){ try { const raw = localStorage.getItem(LB_KEY); if (!raw) return []; return JSON.parse(raw); } catch { return []; } }
function saveLeaderboard(list){ localStorage.setItem(LB_KEY, JSON.stringify(list)); }
function addLeaderboardEntry(name, score){
  const lb = loadLeaderboard();
  lb.push({ name: (name||'---').slice(0,12), score: Math.round(score), date: (new Date()).toISOString() });
  lb.sort((a,b)=> b.score - a.score);
  const truncated = lb.slice(0,5);
  saveLeaderboard(truncated);
  return truncated;
}

/* runtime state */
let running=false, paused=false, lastTime=performance.now(), animId=null;
let scroll=0, speed=CONFIG.baseSpeed, distance=0, score=0, coinsCollectedRun=0, spawnTimer=0;
let platforms=[], coins=[], obstacles=[], powerups=[], particles=[];
const player = { x:160, y:0, w:46, h:66, vy:0, onGround:true, sliding:false, slideTimer:0, jumpsUsed:0, maxJumps:1 };
let activePower = { shield:0, magnet:0, doublejump:0 };

/* UI refs */
const menu = document.getElementById('menu'), shop = document.getElementById('shop'), how = document.getElementById('how');
const pausePanel = document.getElementById('pause'), gameOverPanel = document.getElementById('gameOver');
const coinsChip = document.getElementById('coinsChip'), powerChip = document.getElementById('powerChip');
const scoreVal = document.getElementById('scoreVal'), highScoreEl = document.getElementById('highScore');
const savedCoinsEl = document.getElementById('savedCoins');
const finalScore = document.getElementById('finalScore'), finalCoins = document.getElementById('finalCoins');
const leaderboardEntries = document.getElementById('leaderboardEntries'), gameOverLeaderboard = document.getElementById('gameOverLeaderboard');

/* Input */
const keys = {};
window.addEventListener('keydown',(e)=> {
  keys[e.key.toLowerCase()] = true;
  if (!running && e.key === ' ') startRun();
  if (e.key === 'p') togglePause();
  if (e.key === 'r' && running) restartRun();
  if (running && !paused){
    if (e.key === ' ' || e.code === 'Space') attemptJump();
    if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') startSlide();
  }
});
window.addEventListener('keyup',(e)=> {
  keys[e.key.toLowerCase()] = false;
  if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') stopSlide();
});
canvas.addEventListener('pointerdown',(e)=> {
  if (running && !paused) attemptJump();
  else if (!running) startRun();
});

/* helpers */
function groundY(){ return Math.round(H * 0.14); }
function randRange(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* reset world */
function resetWorld(){
  scroll=0; speed=CONFIG.baseSpeed; distance=0; score=0; coinsCollectedRun=0; spawnTimer=0;
  platforms=[]; coins=[]; obstacles=[]; powerups=[]; particles=[];
  player.y = H - groundY() - player.h; player.vy = 0; player.onGround=true; player.sliding=false; player.slideTimer=0; player.jumpsUsed=0;
  player.maxJumps = save.perks && save.perks['perk_doublejump'] ? 2 : 1;
  platforms.push({ x:-900, y: player.y + player.h, w: 2400, h: 18 });
  for (let i=0;i<3;i++) generateChunk();
}

/* chunk generation (only saw & spike) */
function computeGap(){ return 140 + Math.random()*240; }
function generateChunk(){
  const last = platforms[platforms.length-1];
  let x = last ? (last.x + last.w + computeGap()) : (scroll + W + 120);
  const segments = 2 + Math.floor(Math.random()*4);
  const ground = H - groundY();
  for (let s=0;s<segments;s++){
    const pw = 100 + Math.random()*200;
    const py = ground - 18 + (Math.random()*60 - 20);
    platforms.push({ x:x, y:py, w:pw, h:18 });
    // coins
    if (Math.random() < 0.86){
      const coinCount = 1 + Math.floor(Math.random()*3);
      for (let c=0;c<coinCount;c++) coins.push({ x: x + 16 + Math.random()*(pw-32), y: py - 28 - Math.random()*32, r:8, taken:false });
    }
    // obstacles: saw or spike with balanced probabilities
    const obsRoll = Math.random();
    if (obsRoll < 0.35){
      // saw: conservative speed & short range
      const sx = x + 20 + Math.random()*(pw - 40), sy = py - 30;
      obstacles.push({ type:'saw', x:sx, y:sy, w:34, h:34, dir: (Math.random()<0.5?1:-1), range: 40 + Math.random()*40, speed: 0.9 + Math.random()*0.6, _off:0, _pos:sx });
    } else if (obsRoll < 0.68) {
      // spike, small
      const sx = x + 20 + Math.random()*(pw - 40), sy = py - 30;
      obstacles.push({ type:'spike', x:sx, y:sy, w:26, h:30 });
    }
    // chance of powerup
    if (Math.random() < 0.10) {
      const types = ['shield','magnet','doublejump'];
      const t = types[Math.floor(Math.random()*types.length)];
      powerups.push({ x: x + 12 + Math.random()*(pw - 24), y: py - 44 - Math.random()*22, type:t, picked:false });
    }
    x += pw + computeGap()*0.9;
  }
}

/* grant powerups */
function grantPowerup(type){
  if (type==='shield') activePower.shield = POWERUP_DUR.shield;
  if (type==='magnet') activePower.magnet = POWERUP_DUR.magnet;
  if (type==='doublejump'){ activePower.doublejump = POWERUP_DUR.doublejump; player.maxJumps = Math.max(player.maxJumps, 2); }
}

/* main run functions */
function startRun(){
  resetWorld();
  running=true; paused=false;
  menu.style.display='none'; shop.style.display='none'; how.style.display='none'; gameOverPanel.style.display='none';
  lastTime = performance.now();
  animId = requestAnimationFrame(loop);
}
function restartRun(){ resetWorld(); running=true; paused=false; document.getElementById('gameOver').style.display='none'; lastTime = performance.now(); animId = requestAnimationFrame(loop); }
function togglePause(){ paused = !paused; document.getElementById('pause').style.display = paused ? 'flex' : 'none'; if (!paused){ lastTime = performance.now(); animId = requestAnimationFrame(loop); } else if (animId) cancelAnimationFrame(animId); }
function endRun(){
  running=false;
  if (score > save.highScore) save.highScore = Math.round(score);
  save.totalCoins = (save.totalCoins || 0) + coinsCollectedRun;
  saveGame();
  document.getElementById('finalScore').textContent = Math.round(score);
  document.getElementById('finalCoins').textContent = coinsCollectedRun;
  // show leaderboard on game over
  document.getElementById('gameOverLeaderboard').innerHTML = formatLeaderboard(loadLeaderboard());
  document.getElementById('gameOver').style.display = 'flex';
  applySaveToUI();
  if (animId) cancelAnimationFrame(animId);
}

/* loop */
function loop(now){
  if (!running) return;
  const dt = Math.min(40, now - lastTime); lastTime = now;
  if (!paused) update(dt);
  draw();
  animId = requestAnimationFrame(loop);
}

/* update */
function update(dt){
  // gentle speed ramp
  speed += CONFIG.speedRamp * dt;
  const worldShift = speed * (dt / 16.67);
  scroll += worldShift;
  distance += worldShift * 0.02;
  // slower scoring per px
  score += worldShift * CONFIG.scorePerPx;

  spawnTimer += dt;
  if (spawnTimer > 420){ spawnTimer = 0; generateChunk(); }

  // player physics
  player.vy += CONFIG.gravity * (dt / 16.67);
  player.y += player.vy * (dt / 16.67);
  const ground = H - groundY();
  if (player.y + player.h >= ground){ player.y = ground - player.h; player.vy = 0; player.onGround = true; player.jumpsUsed = 0; } else player.onGround = false;

  // sliding
  if (player.sliding){ player.slideTimer -= dt; if (player.slideTimer <= 0) stopSlide(); }

  // coins: magnet effect and pickups
  for (const c of coins){
    if (c.taken) continue;
    const sx = c.x - scroll;
    if (activePower.magnet > 0 || save.perks['perk_magnet']) {
      if (Math.abs(sx - player.x) < 260) c.x += (player.x - sx) * 0.06 * (dt/16.67);
    }
    const dx = (player.x + player.w/2) - sx, dy = (player.y + player.h/2) - c.y;
    if (Math.sqrt(dx*dx + dy*dy) < 28){ c.taken = true; coinsCollectedRun += CONFIG.coinValue; score += 12; spawnParticles(sx, c.y, '#ffd66b', 10); }
  }

  // obstacles handling (saw & spike only)
  for (let i=0;i<obstacles.length;i++){
    const o = obstacles[i];
    if (o.type === 'saw'){
      // move saw along short track
      o._off = (o._off || 0) + o.dir * o.speed * (dt/16.67);
      if (Math.abs(o._off) > o.range) o.dir *= -1;
      const worldX = (o._pos || o.x) + o._off;
      const sx = worldX - scroll, sy = o.y;
      if (rectsOverlap({x:player.x,y:player.y,w:player.w,h:player.h}, {x:sx,y:sy,w:o.w,h:o.h})){
        if (activePower.shield > 0 || save.perks['perk_shield']){ if (!save.perks['perk_shield']) activePower.shield = 0; spawnParticles(sx + o.w/2, sy + o.h/2, '#ff7d7d', 12); }
        else { endRun(); return; }
      }
    } else if (o.type === 'spike'){
      const sx = o.x - scroll, sy = o.y;
      if (rectsOverlap({x:player.x,y:player.y,w:player.w,h:player.h}, {x:sx,y:sy,w:o.w,h:o.h})){
        if (activePower.shield > 0 || save.perks['perk_shield']){ if (!save.perks['perk_shield']) activePower.shield = 0; spawnParticles(sx + o.w/2, sy + o.h/2, '#ff7d7d', 10); }
        else { endRun(); return; }
      }
    }
  }

  // powerups pickups
  for (const pu of powerups){
    if (pu.picked) continue;
    const sx = pu.x - scroll;
    const dx = (player.x + player.w/2) - sx, dy = (player.y + player.h/2) - pu.y;
    if (Math.sqrt(dx*dx + dy*dy) < 34){ pu.picked = true; grantPowerup(pu.type); spawnParticles(sx, pu.y, pu.type==='magnet' ? '#8affb3' : (pu.type==='shield' ? '#9dd7ff' : '#ffd78a'), 14); score += 24; }
  }

  // cleanup
  coins = coins.filter(c => !c.taken && c.x - scroll > -300);
  platforms = platforms.filter(p => p.x + p.w - scroll > -400);
  powerups = powerups.filter(p => !p.picked && p.x - scroll > -300);
  obstacles = obstacles.filter(o => {
    // spikes and saws are kept if near; saws use position; we'll keep until off-screen behind
    if (o.type === 'saw') {
      const worldX = (o._pos || o.x) + (o._off || 0);
      return (worldX - scroll) > -400;
    } else return (o.x - scroll) > -400;
  });

  // update particles
  for (let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life -= dt;
    p.x += p.vx * (dt/16.67); p.y += p.vy * (dt/16.67); p.vy += 0.08 * (dt/16.67);
    if (p.life <= 0) particles.splice(i,1);
  }

  // power timers
  for (const k of Object.keys(activePower)) { if (activePower[k] > 0) activePower[k] -= dt; if (activePower[k] < 0) activePower[k] = 0; }
  if (activePower.doublejump <= 0 && !save.perks['perk_doublejump']) player.maxJumps = 1;

  applySaveToUI();
}

/* collision helper */
function rectsOverlap(a,b){ return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h); }

/* player actions */
function attemptJump(){
  if (!running || paused) return;
  if (player.onGround){ player.vy = -CONFIG.jumpPower; player.onGround=false; player.jumpsUsed = 1; }
  else {
    const hasPermanent = !!save.perks['perk_doublejump'];
    const hasActive = activePower.doublejump > 0;
    if (player.jumpsUsed < player.maxJumps || hasActive || hasPermanent){ player.vy = -CONFIG.jumpPower * 0.92; player.jumpsUsed++; spawnParticles(player.x + player.w/2, player.y + player.h, '#ffd78a', 10); }
  }
}
function startSlide(){ if (!running || paused) return; if (player.onGround && !player.sliding){ player.sliding = true; player.slideTimer = CONFIG.slideDuration; } }
function stopSlide(){ player.sliding = false; player.slideTimer = 0; }

/* particles */
function spawnParticles(x,y,color,count=8){
  for (let i=0;i<count;i++) particles.push({ x, y, vx:(Math.random()-0.5)*2.8, vy:-Math.random()*3-1, life:300+Math.random()*260, size:2 + Math.random()*3, color });
}

/* draw routine */
function draw(){
  ctx.clearRect(0,0,W,H);
  // background gradient
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#04040a'); g.addColorStop(1,'#0b0b12'); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  drawNeonHills();
  // ground
  const gY = H - groundY();
  ctx.fillStyle = '#07070b'; ctx.fillRect(0, gY, W, groundY()); ctx.fillStyle = '#0f1720'; ctx.fillRect(0, gY+6, W, 4);

  // world transform
  ctx.save(); ctx.translate(-Math.round(scroll), 0);

  // platforms
  for (const p of platforms){ ctx.fillStyle = '#101219'; roundRect(p.x, p.y, p.w, p.h, 8); ctx.strokeStyle = 'rgba(0,215,255,0.04)'; ctx.lineWidth=1; ctx.strokeRect(p.x+1, p.y+1, p.w-2, p.h-2); }

  // coins
  for (const c of coins){ if (c.taken) continue; ctx.fillStyle = '#ffd66b'; circle(c.x, c.y, c.r); ctx.fillStyle = 'rgba(255,255,255,0.06)'; circle(c.x-2,c.y-3,c.r*0.22); }

  // obstacles (only saw and spike)
  for (const o of obstacles){
    if (o.type === 'saw'){
      const cx = (o._pos || o.x) + (o._off || 0);
      const sx = cx, sy = o.y;
      ctx.save(); ctx.translate(sx + o.w/2, sy + o.h/2);
      const rot = performance.now()/120 * (o.dir || 1);
      ctx.rotate(rot);
      ctx.fillStyle = '#d9d9d9'; circle(0,0,o.w*0.5);
      ctx.fillStyle = '#ff6b6b';
      for (let t=0;t<8;t++){ ctx.beginPath(); const ang = t * Math.PI/4; ctx.moveTo(Math.cos(ang)*(o.w*0.45), Math.sin(ang)*(o.w*0.45)); ctx.lineTo(Math.cos(ang+0.18)*(o.w*0.75), Math.sin(ang+0.18)*(o.w*0.75)); ctx.lineTo(Math.cos(ang-0.18)*(o.w*0.75), Math.sin(ang-0.18)*(o.w*0.75)); ctx.closePath(); ctx.fill(); }
      ctx.restore();
    } else if (o.type === 'spike'){
      const sx = o.x, sy = o.y;
      ctx.fillStyle = '#ff6b6b';
      const spikeCount = Math.max(2, Math.floor(o.w / 12));
      for (let s=0;s<spikeCount;s++){ const cx = sx + 6 + s*12; ctx.beginPath(); ctx.moveTo(cx-6, sy + o.h); ctx.lineTo(cx, sy); ctx.lineTo(cx+6, sy + o.h); ctx.closePath(); ctx.fill(); }
    }
  }

  // powerups
  for (const pu of powerups){ const px = pu.x, py = pu.y; if (pu.type === 'shield'){ ctx.fillStyle='#9dd7ff'; circle(px,py,12); } else if (pu.type==='magnet'){ ctx.fillStyle='#8affb3'; circle(px,py,12); } else { ctx.fillStyle='#ffd78a'; circle(px,py,12);} ctx.fillStyle='rgba(0,0,0,0.12)'; circle(px,py,6); }

  ctx.restore();

  // draw edgy player
  drawEvilPlayer();

  // particles on top
  for (const p of particles){ ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life/400); circle(p.x,p.y,p.size); ctx.globalAlpha = 1; }

  // HUD updates
  document.getElementById('scoreVal').textContent = Math.round(score);
  let activeText = '—';
  if (activePower.shield > 0) activeText = 'Shield ⏳' + Math.ceil(activePower.shield/1000)+'s';
  else if (activePower.magnet > 0) activeText = 'Magnet ⏳' + Math.ceil(activePower.magnet/1000)+'s';
  else if (activePower.doublejump > 0) activeText = 'Double-Jump ⏳' + Math.ceil(activePower.doublejump/1000)+'s';
  else {
    const perks = [];
    if (save.perks['perk_doublejump']) perks.push('DJ');
    if (save.perks['perk_magnet']) perks.push('MG');
    if (save.perks['perk_shield']) perks.push('SH');
    if (perks.length) activeText = perks.join(' ');
  }
  document.getElementById('powerChip').textContent = 'Power: ' + activeText;
}

/* draw evil player (similar to v2 but tuned) */
function drawEvilPlayer(){
  let dx = player.x, dy = player.y, dw = player.w, dh = player.h;
  if (player.sliding){ dh = Math.round(player.h*0.56); dy = player.y + (player.h - dh); }
  const skin = SKINS.find(s => s.id === save.equipped) || SKINS[0];
  ctx.fillStyle = skin.color; roundRect(dx,dy,dw,dh,10);
  // mouth jagged
  ctx.fillStyle = '#081018';
  ctx.beginPath();
  const mouthY = dy + dh*0.68;
  ctx.moveTo(dx + dw*0.2, mouthY);
  const teeth = 5;
  for (let i=0;i<teeth;i++){ const tx = dx + dw*0.2 + (i*(dw*0.6)/teeth); const ty = mouthY + ((i%2===0)?6:-6); ctx.lineTo(tx,ty); }
  ctx.lineTo(dx + dw*0.8, mouthY); ctx.closePath(); ctx.fill();
  // horns
  ctx.fillStyle = '#0b0b0f';
  ctx.beginPath(); ctx.moveTo(dx + dw*0.18, dy - 6); ctx.lineTo(dx + dw*0.32, dy + 2); ctx.lineTo(dx + dw*0.06, dy + 4); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(dx + dw*0.82, dy - 6); ctx.lineTo(dx + dw*0.68, dy + 2); ctx.lineTo(dx + dw*0.94, dy + 4); ctx.closePath(); ctx.fill();
  // glowing eyes
  ctx.fillStyle = (skin.accent || '#ff6b6b'); ctx.beginPath(); ctx.ellipse(dx + dw*0.28, dy + dh*0.3, 5, 8, 0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(dx + dw*0.72, dy + dh*0.3, 5, 8, 0,0,Math.PI*2); ctx.fill();
  // cape
  ctx.fillStyle = 'rgba(5,6,8,0.9)'; ctx.beginPath(); ctx.moveTo(dx + dw*0.5, dy + dh*0.2); ctx.bezierCurveTo(dx + dw*0.9, dy + dh*0.4, dx + dw*0.9, dy + dh*0.95, dx + dw*0.2, dy + dh*1.12); ctx.closePath(); ctx.fill();
}

/* neon hills */
function drawNeonHills(){
  for (let i=0;i<3;i++){
    ctx.fillStyle = ['rgba(10,10,18,0.7)','rgba(8,10,14,0.6)','rgba(6,8,12,0.5)'][i];
    ctx.beginPath();
    const amp = 80 + i*20;
    ctx.moveTo(-200, H*0.86 - i*36);
    for (let x=-200;x<=W+400;x+=100){
      const y = H*0.86 - i*36 - Math.sin((x*0.002)+(i*0.6))*amp;
      ctx.lineTo(x,y);
    }
    ctx.lineTo(W+400,H+200); ctx.lineTo(-200,H+200); ctx.closePath(); ctx.fill();
  }
}

/* helpers */
function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }
function circle(x,y,r){ ctx.beginPath(); ctx.ellipse(x,y,r,r,0,0,Math.PI*2); ctx.fill(); }

/* UI and Shop */
function applySaveToUI(){
  document.getElementById('highScore').textContent = Math.round(save.highScore || 0);
  document.getElementById('savedCoins').textContent = Math.round(save.totalCoins || 0);
  document.getElementById('coinsChip').textContent = 'Coins: ' + ( (save.totalCoins || 0) + coinsCollectedRun );
  // leaderboard in menu
  leaderboardEntries.innerHTML = formatLeaderboard(loadLeaderboard());
}
function buildShop(){
  const grid = document.getElementById('shopGrid'); grid.innerHTML = '';
  for (const s of SKINS){
    const card = document.createElement('div'); card.className = 'skinCard';
    const preview = document.createElement('div'); preview.className = 'skinPreview'; preview.style.background = s.color; preview.textContent = s.name[0];
    const name = document.createElement('div'); name.textContent = s.name; name.style.fontWeight='700';
    const price = document.createElement('div'); price.textContent = s.price === 0 ? 'Free' : s.price + ' coins';
    const btn = document.createElement('button'); btn.className='btn'; btn.style.width='100%';
    const owned = (save.ownedSkins || []).includes(s.id);
    if (owned){ btn.textContent = (save.equipped === s.id) ? 'Equipped' : 'Equip'; btn.onclick = ()=> { save.equipped = s.id; saveGame(); applySaveToUI(); buildShop(); }; }
    else { btn.textContent = 'Buy'; btn.onclick = ()=> { if ((save.totalCoins || 0) >= s.price){ save.totalCoins -= s.price; (save.ownedSkins || (save.ownedSkins=[])).push(s.id); save.equipped = s.id; saveGame(); applySaveToUI(); buildShop(); } else alert('Not enough coins'); }; }
    card.appendChild(preview); card.appendChild(name); card.appendChild(price); card.appendChild(btn); grid.appendChild(card);
  }
  // perks
  for (const p of PERKS){
    const card = document.createElement('div'); card.className='skinCard';
    const name = document.createElement('div'); name.textContent = p.name; name.style.fontWeight='700';
    const price = document.createElement('div'); price.textContent = p.price + ' coins';
    const btn = document.createElement('button'); btn.className='btn alt'; btn.style.width='100%';
    const owned = !!(save.perks && save.perks[p.key]);
    btn.textContent = owned ? 'Owned' : 'Buy';
    btn.addEventListener('click', ()=> {
      if (owned) return;
      if ((save.totalCoins || 0) >= p.price) { save.totalCoins -= p.price; save.perks = save.perks || {}; save.perks[p.key] = true; saveGame(); applySaveToUI(); buildShop(); alert(`${p.name} purchased.`); } else alert('Not enough coins');
    });
    card.appendChild(name); card.appendChild(price); card.appendChild(btn); grid.appendChild(card);
  }
}

/* leaderboard display helper */
function formatLeaderboard(list){
  if (!list || !list.length) return '<div style="opacity:0.8">No entries yet</div>';
  let out = '<ol style="padding-left:18px;margin:6px 0;">';
  for (const e of list) out += `<li style="margin-bottom:4px;"><strong style="color:#fff">${e.name}</strong> — ${e.score}</li>`;
  out += '</ol>';
  return out;
}

/* event wiring */
document.getElementById('startBtn').addEventListener('click', ()=> startRun());
document.getElementById('shopBtn').addEventListener('click', ()=> { menu.style.display='none'; shop.style.display='flex'; buildShop(); });
document.getElementById('howBtn').addEventListener('click', ()=> { menu.style.display='none'; how.style.display='flex'; });
document.getElementById('howBack').addEventListener('click', ()=> { how.style.display='none'; menu.style.display='flex'; });
document.getElementById('shopBack').addEventListener('click', ()=> { shop.style.display='none'; menu.style.display='flex'; });
document.getElementById('resetBtn').addEventListener('click', ()=> { if (confirm('Reset save? Clears high score, coins, skins and perks.')) { localStorage.removeItem(SAVE_KEY); localStorage.removeItem(LB_KEY); save = loadSave(); applySaveToUI(); buildShop(); alert('Save and leaderboard cleared.'); }});
document.getElementById('resumeBtn').addEventListener('click', ()=> togglePause());
document.getElementById('restartBtn').addEventListener('click', ()=> restartRun());
document.getElementById('tryBtn').addEventListener('click', ()=> { restartRun(); document.getElementById('gameOver').style.display='none'; });
document.getElementById('menuBtn').addEventListener('click', ()=> { document.getElementById('gameOver').style.display='none'; menu.style.display='flex'; });
document.getElementById('saveScoreBtn').addEventListener('click', ()=> {
  const name = document.getElementById('playerName').value.trim() || '---';
  const lb = addLeaderboardEntry(name, score);
  document.getElementById('gameOverLeaderboard').innerHTML = formatLeaderboard(lb);
  applySaveToUI();
});
document.getElementById('playerName').addEventListener('keydown',(e)=> { if (e.key === 'Enter') document.getElementById('saveScoreBtn').click(); });

/* init */
resetWorld();
applySaveToUI();
buildShop();
menu.style.display='flex'; shop.style.display='none'; how.style.display='none'; pausePanel.style.display='none'; gameOverPanel.style.display='none';

/* expose leaderboard initially */
document.getElementById('leaderboardEntries').innerHTML = formatLeaderboard(loadLeaderboard());

</script>
</body>
</html>
