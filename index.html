<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Run Raider — Dark Endless Runner with Power-ups</title>
<style>
  :root{
    --bg1:#07070b; --bg2:#0f1016; --panel:#0f1720; --accent:#00e5ff; --accent2:#ff6b6b; --muted:#9aa3b2;
  }
  html,body{ height:100%; margin:0; background:linear-gradient(180deg,var(--bg1),var(--bg2)); color:#dfe7ef; font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  canvas{ display:block; width:100vw; height:100vh; background:transparent; }
  /* UI overlay */
  #ui{ position:absolute; inset:0; pointer-events:none; }
  .panel{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); border-radius:12px; padding:12px; box-shadow:0 8px 30px rgba(0,0,0,0.6); color:#e6eef6; }
  .center{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:auto; }
  .menuBox{ width:840px; max-width:94%; text-align:center; gap:8px; display:flex; flex-direction:column; align-items:center; }
  h1{ margin:0; font-size:34px; letter-spacing:0.6px; color:#ffffff; text-shadow:0 6px 30px rgba(0,0,0,0.6); }
  p.lead{ margin:0; color:var(--muted); font-size:13px; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
  button.btn{ pointer-events:auto; border:0; padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer; background:linear-gradient(180deg,#0ff9ff10,#00e5ff14); color:var(--accent); border:1px solid rgba(0,229,255,0.06); }
  button.btn.alt{ background:linear-gradient(180deg,#ff6b6b10,#ff6b6b12); color:var(--accent2); border:1px solid rgba(255,107,107,0.06); }
  button.btn.ghost{ background:transparent; color:var(--muted); border:1px dashed rgba(255,255,255,0.04); }
  #hud{ position:absolute; left:16px; top:12px; display:flex; gap:10px; align-items:center; pointer-events:none; }
  .chip{ background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); font-weight:700; font-size:13px; color:#dfe7ef; }
  #bigScore{ position:absolute; left:50%; transform:translateX(-50%); top:12px; pointer-events:none; background:rgba(255,255,255,0.02); padding:8px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.03); font-weight:800; font-size:18px; }
  #controls{ position:absolute; bottom:12px; left:12px; pointer-events:none; background:rgba(255,255,255,0.02); border-radius:10px; padding:8px; border:1px solid rgba(255,255,255,0.02); color:var(--muted); font-size:13px; }
  /* shop grid */
  #shopGrid{ display:grid; grid-template-columns: repeat(auto-fit,minmax(140px,1fr)); gap:10px; width:760px; max-width:94%; }
  .skinCard{ background:rgba(255,255,255,0.02); padding:10px; border-radius:10px; display:flex; flex-direction:column; gap:8px; align-items:center; pointer-events:auto; border:1px solid rgba(255,255,255,0.02); }
  .skinPreview{ width:68px; height:86px; border-radius:8px; display:flex; align-items:center; justify-content:center; font-weight:800; box-shadow: 0 8px 18px rgba(0,0,0,0.6); color:#101218; }
  /* small responsive */
  @media (max-width:720px){ h1{ font-size:26px } .menuBox{ padding:10px } #shopGrid{ grid-template-columns:repeat(2,1fr) } }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
  <div id="hud">
    <div class="chip" id="coinsChip">Coins: 0</div>
    <div class="chip" id="powerChip">Power: —</div>
  </div>

  <div id="bigScore">RUN RAIDER — Score: <span id="scoreVal">0</span></div>

  <!-- Main Menu -->
  <div id="menu" class="center">
    <div class="menuBox panel">
      <h1>RUN RAIDER</h1>
      <p class="lead">Darker, serious neon-runner. Collect power-ups: Shield, Magnet, Double-Jump. Survive and climb the leaderboard.</p>
      <div class="row">
        <button id="startBtn" class="btn">Start (Space)</button>
        <button id="shopBtn" class="btn">Shop</button>
        <button id="howBtn" class="btn ghost">How to Play</button>
        <button id="resetBtn" class="btn alt">Reset Save</button>
      </div>
      <div style="margin-top:8px; display:flex; gap:8px; justify-content:center; align-items:center;">
        <div style="text-align:center; color:var(--muted)">High Score<br><strong id="highScore">0</strong></div>
        <div style="width:18px"></div>
        <div style="text-align:center; color:var(--muted)">Total Coins<br><strong id="savedCoins">0</strong></div>
      </div>
    </div>
  </div>

  <!-- How to play -->
  <div id="how" class="center" style="display:none; pointer-events:auto;">
    <div class="panel menuBox">
      <h1>How to Play</h1>
      <p class="lead">Space: jump (double-jump if you have it) • Down / S: slide • Collect coins and power-ups. P: pause, R: restart. Power-ups last briefly — plan their use.</p>
      <div class="row"><button id="howBack" class="btn">Back</button></div>
    </div>
  </div>

  <!-- Shop -->
  <div id="shop" class="center" style="display:none; pointer-events:auto;">
    <div class="panel menuBox">
      <h1>Shop — Skins & Power-ups</h1>
      <p class="lead">Buy skins with coins. Power-ups can be bought as permanent perks (optional) or found during runs.</p>
      <div id="shopGrid"></div>
      <div class="row" style="margin-top:8px;"><button id="shopBack" class="btn">Close</button></div>
    </div>
  </div>

  <!-- Pause -->
  <div id="pause" class="center" style="display:none; pointer-events:auto;">
    <div class="panel menuBox">
      <h1>Paused</h1>
      <p class="lead">P to resume or R to restart.</p>
      <div class="row"><button id="resumeBtn" class="btn">Resume (P)</button><button id="restartBtn" class="btn alt">Restart (R)</button></div>
    </div>
  </div>

  <!-- Game Over -->
  <div id="gameOver" class="center" style="display:none; pointer-events:auto;">
    <div class="panel menuBox">
      <h1>Run Over</h1>
      <p class="lead">Score <strong id="finalScore">0</strong> • Coins collected <strong id="finalCoins">0</strong></p>
      <div class="row"><button id="tryBtn" class="btn">Try Again</button><button id="menuBtn" class="btn ghost">Back to Menu</button></div>
    </div>
  </div>

  <div id="controls" class="chip">Space = Jump • Down/S = Slide • P = Pause • R = Restart</div>
</div>

<script>
/* Run Raider
 - Darker neon style endless runner
 - Power-ups: Shield (invulnerable), Magnet (pulls coins), Double-Jump
 - Shop with skins and optional permanent perks
 - LocalStorage save for high score, coins, owned skins, equipped skin, purchased perks
 - Buttons and UI fixed to be clickable
*/

// Canvas setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
window.addEventListener('resize', ()=> { W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

/* ---------------------
   Game config and state
   --------------------- */
const CONFIG = {
  gravity: 0.56,
  jumpPower: 12.2,
  baseSpeed: 3.4,
  speedScalePer100: 0.6,
  slideDuration: 520,
  coinValue: 1
};

// power-up durations (ms)
const POWERUP_DUR = {
  shield: 4500,
  magnet: 5000,
  doublejump: 7500
};

// skins and shop items
const SKINS = [
  { id:'raider', name:'Raider', color:'#2ee8ff', price:0 },
  { id:'onyx', name:'Onyx', color:'#9fb6ff', price:40 },
  { id:'ember', name:'Ember', color:'#ff7d7d', price:85 },
  { id:'neon', name:'Neon', color:'#8affb3', price:140 },
  { id:'void', name:'Void', color:'#bdb7ff', price:220 },
];
// permanent perks in shop (optional): buy to spawn with the perk permanently
const PERKS = [
  { id:'perk_doublejump', name:'Permanent Double-Jump', price:150, key:'perk_doublejump' },
  { id:'perk_magnet', name:'Permanent Magnet', price:130, key:'perk_magnet' },
  { id:'perk_shield', name:'Permanent Shield', price:170, key:'perk_shield' }
];

// localStorage key
const SAVE_KEY = 'run_raider_v1';

// Save structure: { highScore, totalCoins, ownedSkins[], equipped, perks: {perk_doublejump:true,...} }
function loadSave() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return { highScore:0, totalCoins:0, ownedSkins:['raider'], equipped:'raider', perks:{} };
    const p = JSON.parse(raw);
    return {
      highScore: p.highScore || 0,
      totalCoins: p.totalCoins || 0,
      ownedSkins: Array.isArray(p.ownedSkins) ? p.ownedSkins : ['raider'],
      equipped: p.equipped || 'raider',
      perks: p.perks || {}
    };
  } catch (e) {
    return { highScore:0, totalCoins:0, ownedSkins:['raider'], equipped:'raider', perks:{} };
  }
}
function saveGame() { localStorage.setItem(SAVE_KEY, JSON.stringify(save)); }
let save = loadSave();

/* ---------------------
   Runtime state
   --------------------- */
let running = false, paused = false;
let lastTime = performance.now();

// world / runner
let scroll = 0;      // total pixels scrolled
let speed = CONFIG.baseSpeed;
let distance = 0;
let score = 0;
let coinsCollectedRun = 0;
let spawnTimer = 0;

// entities: platforms, coins, obstacles, powerups
let platforms = [], coins = [], obstacles = [], powerups = [], particles = [];

// player
const player = {
  x: 160, y: 0, w: 44, h: 60,
  vy: 0, onGround: true, sliding: false, slideTimer:0,
  jumpsUsed:0, maxJumps:1
};

// active power-ups (timed)
let activePower = { shield:0, magnet:0, doublejump:0 };

// UI refs
const menu = document.getElementById('menu'), shop = document.getElementById('shop'), how = document.getElementById('how');
const pausePanel = document.getElementById('pause'), gameOverPanel = document.getElementById('gameOver');
const coinsChip = document.getElementById('coinsChip'), powerChip = document.getElementById('powerChip');
const scoreVal = document.getElementById('scoreVal'), highScoreEl = document.getElementById('highScore');
const savedCoinsEl = document.getElementById('savedCoins');
const finalScore = document.getElementById('finalScore'), finalCoins = document.getElementById('finalCoins');

applySaveToUI();

/* ---------------------
   Input handling
   --------------------- */
const keys = {};
window.addEventListener('keydown', (e)=> {
  keys[e.key.toLowerCase()] = true;
  if (!running && e.key === ' ') startRun();
  if (e.key === 'p') togglePause();
  if (e.key === 'r' && running) restartRun();
  // gameplay keys
  if (running && !paused) {
    if (e.key === ' ' || e.code === 'Space') attemptJump();
    if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') startSlide();
  }
});
window.addEventListener('keyup', (e)=> {
  keys[e.key.toLowerCase()] = false;
  if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') stopSlide();
});
// pointer tap => jump
canvas.addEventListener('pointerdown', (e)=> {
  if (running && !paused) attemptJump();
  else if (!running) startRun();
});

/* ---------------------
   Generation helpers
   --------------------- */
function groundY() { return Math.round(H * 0.14); }
function resetWorld() {
  scroll = 0; speed = CONFIG.baseSpeed; distance = 0; score = 0; coinsCollectedRun = 0; spawnTimer = 0;
  platforms = []; coins = []; obstacles = []; powerups = []; particles = [];
  player.y = H - groundY() - player.h; player.vy = 0; player.onGround = true; player.sliding=false; player.slideTimer=0; player.jumpsUsed=0;
  // initial long platform
  platforms.push({ x:-800, y: player.y + player.h, w: 2200, h: 18 });
  // spawn some initial chunks
  for (let i=0;i<3;i++) generateChunk();
  // grant starting permanent perks if purchased
  if (save.perks && save.perks['perk_doublejump']) player.maxJumps = 2; else player.maxJumps = 1;
  if (save.perks && save.perks['perk_doublejump']) player.jumpsUsed = 0;
}

/* conservative spacing and chunk gen */
function computeGap() {
  // random gap in px
  return 120 + Math.random()*300;
}

function generateChunk() {
  // append platforms, coins, obstacles, powerups further to the right
  const last = platforms[platforms.length-1];
  let x = last ? (last.x + last.w + computeGap()) : (scroll + W + 120);
  const segments = 2 + Math.floor(Math.random()*4);
  const ground = H - groundY();
  for (let s=0; s<segments; s++){
    const pw = 100 + Math.random()*220;
    const py = ground - 18 + (Math.random()*80 - 30);
    platforms.push({ x: x, y: py, w: pw, h: 18 });
    // maybe add coins
    if (Math.random() < 0.86) {
      const coinCount = 1 + Math.floor(Math.random()*3);
      for (let c=0;c<coinCount;c++){
        coins.push({ x: x + 16 + Math.random()*(pw - 32), y: py - 28 - Math.random()*36, r: 8, taken:false });
      }
    }
    // maybe obstacle (spike)
    if (Math.random() < 0.36) {
      obstacles.push({ x: x + 20 + Math.random()*(pw - 40), y: py - 30, w: 26, h: 30 });
    }
    // rarely spawn power-up pickup
    if (Math.random() < 0.12) {
      const types = ['shield','magnet','doublejump'];
      const t = types[Math.floor(Math.random()*types.length)];
      powerups.push({ x: x + 12 + Math.random()*(pw - 24), y: py - 44 - Math.random()*20, type: t, picked:false });
    }
    x += pw + computeGap()*0.9;
  }
}

/* ---------------------
   Power-up logic
   --------------------- */
function grantPowerup(type) {
  if (type === 'shield') {
    activePower.shield = POWERUP_DUR.shield;
  } else if (type === 'magnet') {
    activePower.magnet = POWERUP_DUR.magnet;
  } else if (type === 'doublejump') {
    activePower.doublejump = POWERUP_DUR.doublejump;
    player.maxJumps = Math.max(player.maxJumps, 2);
  }
}

/* ---------------------
   Main loop & update
   --------------------- */
let animId = null;
function startRun() {
  resetWorld();
  running = true; paused = false;
  document.getElementById('menu').style.display = 'none';
  document.getElementById('shop').style.display = 'none';
  document.getElementById('how').style.display = 'none';
  document.getElementById('gameOver').style.display = 'none';
  lastTime = performance.now();
  animId = requestAnimationFrame(loop);
}

function restartRun() { resetWorld(); running = true; paused = false; document.getElementById('gameOver').style.display='none'; lastTime = performance.now(); animId = requestAnimationFrame(loop); }

function togglePause(){
  paused = !paused;
  document.getElementById('pause').style.display = paused ? 'flex' : 'none';
  if (!paused) {
    lastTime = performance.now();
    animId = requestAnimationFrame(loop);
  } else {
    if (animId) cancelAnimationFrame(animId);
  }
}

function endRun() {
  running = false;
  // finalize score & save coins
  if (score > save.highScore) save.highScore = Math.round(score);
  save.totalCoins = (save.totalCoins || 0) + coinsCollectedRun;
  saveGame();
  // show game over
  document.getElementById('finalScore').textContent = Math.round(score);
  document.getElementById('finalCoins').textContent = coinsCollectedRun;
  document.getElementById('gameOver').style.display = 'flex';
  applySaveToUI();
  if (animId) cancelAnimationFrame(animId);
}

function loop(now) {
  if (!running) return;
  const dt = Math.min(40, now - lastTime); lastTime = now;
  if (!paused) update(dt);
  draw();
  animId = requestAnimationFrame(loop);
}

function update(dt) {
  // speed scaling with distance
  const speedFactor = 1 + (distance / 100) * (CONFIG.speedScalePer100 / 100);
  speed = CONFIG.baseSpeed + speedFactor;
  const worldShift = speed * (dt / 16.67);
  scroll += worldShift;
  distance += worldShift * 0.02;
  score += worldShift * 0.25;

  // spawn new chunks
  spawnTimer += dt;
  if (spawnTimer > 420) { spawnTimer = 0; generateChunk(); }

  // player physics
  player.vy += CONFIG.gravity * (dt / 16.67);
  player.y += player.vy * (dt / 16.67);
  // ground
  const ground = H - groundY();
  if (player.y + player.h >= ground) {
    player.y = ground - player.h;
    player.vy = 0;
    player.onGround = true;
    player.jumpsUsed = 0;
  } else {
    player.onGround = false;
  }

  // slide handling
  if (player.sliding) {
    player.slideTimer -= dt;
    if (player.slideTimer <= 0) stopSlide();
  }

  // move platforms/coins/obstacles relative to scroll: we keep world coords and detect collisions subtracting scroll
  // coins collect
  for (const c of coins) {
    if (c.taken) continue;
    const sx = c.x - scroll;
    // magnet effect
    if (activePower.magnet > 0) {
      // If within 240px horizontally, slowly pull toward player
      if (Math.abs(sx - player.x) < 260) {
        c.x += (player.x - sx) * 0.06; // in world coords, approximate attract
      }
    }
    const dx = (player.x + player.w/2) - sx;
    const dy = (player.y + player.h/2) - c.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 28) {
      c.taken = true;
      coinsCollectedRun += CONFIG.coinValue;
      score += 16;
      spawnParticles(sx, c.y, '#ffd66b', 10);
    }
  }

  // obstacles collision
  for (const o of obstacles) {
    const ox = o.x - scroll;
    const oy = o.y;
    // rectangle collision with player
    const pRect = { x: player.x, y: player.y, w: player.w, h: player.h };
    const oRect = { x: ox, y: oy, w: o.w, h: o.h };
    if (rectsOverlap(pRect, oRect)) {
      if (activePower.shield > 0 || save.perks['perk_shield']) {
        // consume shield if active (if permanent perk, we don't consume)
        if (!save.perks['perk_shield']) activePower.shield = 0;
        // destroy obstacle visually
        spawnParticles(ox + o.w/2, oy + o.h/2, '#ff7d7d', 12);
      } else {
        // death
        endRun(); return;
      }
    }
  }

  // powerup pickups
  for (const pu of powerups) {
    if (pu.picked) continue;
    const sx = pu.x - scroll;
    const dx = (player.x + player.w/2) - sx;
    const dy = (player.y + player.h/2) - pu.y;
    if (Math.sqrt(dx*dx + dy*dy) < 34) {
      pu.picked = true;
      grantPowerup(pu.type);
      spawnParticles(sx, pu.y, pu.type === 'magnet' ? '#8affb3' : (pu.type==='shield' ? '#9dd7ff' : '#ffd78a'), 14);
      score += 28;
    }
  }

  // timers for active power-ups
  for (const k of Object.keys(activePower)) {
    if (activePower[k] > 0) activePower[k] -= dt;
    if (activePower[k] < 0) activePower[k] = 0;
  }
  // if doublejump expired and no perk, reset maxJumps
  if (activePower.doublejump <= 0 && !save.perks['perk_doublejump']) player.maxJumps = 1;

  // clean up old entities behind screen
  platforms = platforms.filter(p => p.x + p.w - scroll > -400);
  coins = coins.filter(c => !c.taken && c.x - scroll > -300);
  obstacles = obstacles.filter(o => o.x - scroll > -300);
  powerups = powerups.filter(pu => !pu.picked && pu.x - scroll > -300);

  // update particles
  for (let i = particles.length-1; i>=0; i--) {
    const p = particles[i];
    p.life -= dt;
    p.x += p.vx * (dt/16.67); p.y += p.vy * (dt/16.67);
    p.vy += 0.08 * (dt/16.67);
    if (p.life <= 0) particles.splice(i,1);
  }

  // update HUD / UI
  applySaveToUI();
}

/* ---------------------
   Collision helpers
   --------------------- */
function rectsOverlap(a,b){ return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h); }

/* ---------------------
   Player actions: jump / slide
   --------------------- */
function attemptJump(){
  if (!running || paused) return;
  if (player.onGround) {
    player.vy = -CONFIG.jumpPower;
    player.onGround = false;
    player.jumpsUsed = 1;
  } else {
    // mid-air double-jump allowed if available
    const canPermanent = !!save.perks['perk_doublejump'];
    const canActive = activePower.doublejump > 0;
    if ((player.jumpsUsed < player.maxJumps) || canPermanent || canActive) {
      player.vy = -CONFIG.jumpPower * 0.9;
      player.jumpsUsed++;
      // if doublejump was active (timed) it does not stack; if permanent, keep maxJumps
      spawnParticles(player.x + player.w/2, player.y + player.h, '#ffd78a', 10);
    }
  }
}

function startSlide(){
  if (!running || paused) return;
  if (player.onGround && !player.sliding) {
    player.sliding = true;
    player.slideTimer = CONFIG.slideDuration;
  }
}
function stopSlide(){
  player.sliding = false;
  player.slideTimer = 0;
}

/* ---------------------
   Grant power-ups (timed)
   --------------------- */
function grantPowerup(type){
  if (type === 'shield') activePower.shield = POWERUP_DUR.shield;
  if (type === 'magnet') activePower.magnet = POWERUP_DUR.magnet;
  if (type === 'doublejump') {
    activePower.doublejump = POWERUP_DUR.doublejump;
    player.maxJumps = Math.max(player.maxJumps, 2);
  }
}

/* ---------------------
   Particles
   --------------------- */
function spawnParticles(x,y,color,count=8){
  for (let i=0;i<count;i++){
    particles.push({
      x, y,
      vx: (Math.random()-0.5) * 2.6,
      vy: -Math.random()*3 - 1,
      life: 300 + Math.random()*240,
      size: 2 + Math.random()*3,
      color
    });
  }
}

/* ---------------------
   Draw routine (darker, neon aesthetics)
   --------------------- */
function draw(){
  // background
  ctx.clearRect(0,0,W,H);
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#070712'); g.addColorStop(1,'#0f1018');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // parallax neon skyline
  drawNeonHills();

  // ground band
  const gY = H - groundY();
  ctx.fillStyle = '#0b0f14'; ctx.fillRect(0, gY, W, groundY());
  ctx.fillStyle = '#0f1720'; ctx.fillRect(0, gY+6, W, 4);

  // world transform: draw world items relative to scroll
  ctx.save();
  ctx.translate(-Math.round(scroll), 0);

  // platforms
  for (const p of platforms) {
    ctx.fillStyle = '#101825';
    roundRect(p.x, p.y, p.w, p.h, 8, true);
    // neon rim
    ctx.strokeStyle = 'rgba(0,229,255,0.06)'; ctx.lineWidth = 1;
    ctx.strokeRect(p.x+1, p.y+1, p.w-2, p.h-2);
  }

  // coins
  for (const c of coins) {
    if (c.taken) continue;
    ctx.fillStyle = '#ffd66b';
    circle(c.x, c.y, c.r);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    circle(c.x - 2, c.y - 3, c.r*0.22);
  }

  // obstacles (spikes)
  for (const o of obstacles) {
    const sx = o.x, sy = o.y;
    ctx.fillStyle = '#ff6b6b';
    const spikeCount = Math.max(2, Math.floor(o.w/12));
    for (let i=0;i<spikeCount;i++){
      const cx = sx + 6 + i*12;
      ctx.beginPath(); ctx.moveTo(cx - 6, sy + o.h); ctx.lineTo(cx, sy); ctx.lineTo(cx + 6, sy + o.h); ctx.closePath(); ctx.fill();
    }
  }

  // powerups pickups
  for (const pu of powerups){
    const px = pu.x, py = pu.y;
    if (pu.type === 'shield') {
      ctx.fillStyle = '#9dd7ff';
      circle(px, py, 12);
    } else if (pu.type === 'magnet') {
      ctx.fillStyle = '#8affb3';
      circle(px, py, 12);
    } else if (pu.type === 'doublejump') {
      ctx.fillStyle = '#ffd78a';
      circle(px, py, 12);
    }
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; circle(px, py, 6);
  }

  ctx.restore();

  // draw player (screen coords)
  let drawX = player.x, drawY = player.y;
  let drawW = player.w, drawH = player.h;
  if (player.sliding) { drawH = Math.round(player.h * 0.56); drawY = player.y + (player.h - drawH); }
  const skin = SKINS.find(s=> s.id === save.equipped) || SKINS[0];
  ctx.fillStyle = skin.color;
  roundRect(drawX, drawY, drawW, drawH, 10, true);
  // eyes (neon)
  ctx.fillStyle = '#081018'; ctx.beginPath(); ctx.ellipse(drawX + drawW*0.28, drawY + drawH*0.34, 4,5,0,0,Math.PI*2); ctx.ellipse(drawX + drawW*0.72, drawY + drawH*0.34, 4,5,0,0,Math.PI*2); ctx.fill();
  // shield visual
  if (activePower.shield > 0 || save.perks['perk_shield']) {
    ctx.strokeStyle = 'rgba(157,215,255,0.35)'; ctx.lineWidth = 6;
    ctx.beginPath(); ctx.ellipse(drawX + drawW/2, drawY + drawH/2, drawW*0.9, drawH*0.9, 0, 0, Math.PI*2); ctx.stroke();
  }

  // particles
  for (const p of particles) {
    ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life / 400); circle(p.x, p.y, p.size); ctx.globalAlpha = 1;
  }

  // power-up icon on HUD
  let activeText = '—';
  if (activePower.shield > 0) activeText = 'Shield ⏳' + Math.ceil(activePower.shield/1000)+'s';
  else if (activePower.magnet > 0) activeText = 'Magnet ⏳' + Math.ceil(activePower.magnet/1000)+'s';
  else if (activePower.doublejump > 0) activeText = 'Double-Jump ⏳' + Math.ceil(activePower.doublejump/1000)+'s';
  else {
    // permanent perks
    if (save.perks && (save.perks['perk_doublejump'] || save.perks['perk_magnet'] || save.perks['perk_shield'])) {
      const perks = [];
      if (save.perks['perk_doublejump']) perks.push('DJ');
      if (save.perks['perk_magnet']) perks.push('MG');
      if (save.perks['perk_shield']) perks.push('SH');
      activeText = perks.join(' ');
    }
  }
  document.getElementById('powerChip').textContent = 'Power: ' + activeText;
  document.getElementById('scoreVal').textContent = Math.round(score);
}

/* ---------------------
   Helper draw functions
   --------------------- */
function roundRect(x,y,w,h,r,fill=true){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if (fill) ctx.fill(); }
function circle(x,y,r){ ctx.beginPath(); ctx.ellipse(x,y,r,r,0,0,Math.PI*2); ctx.fill(); }
function drawNeonHills(){
  // subtle parallax neon shapes
  for (let i=0;i<3;i++){
    ctx.fillStyle = ['rgba(30,30,50,0.6)','rgba(12,18,30,0.6)','rgba(6,10,18,0.6)'][i];
    ctx.beginPath();
    const amp = 80 + i*20;
    ctx.moveTo(-200, H*0.86 - i*36);
    for (let x=-200; x<=W+400; x+=100) {
      const y = H*0.86 - i*36 - Math.sin((x*0.002)+(i*0.6)) * amp;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(W+400, H+200); ctx.lineTo(-200, H+200); ctx.closePath(); ctx.fill();
  }
}

/* ---------------------
   UI: shop, menu, events
   --------------------- */
document.getElementById('startBtn').addEventListener('click', ()=> startRun());
document.getElementById('shopBtn').addEventListener('click', ()=> { menu.style.display = 'none'; shop.style.display = 'flex'; buildShop(); });
document.getElementById('howBtn').addEventListener('click', ()=> { menu.style.display='none'; how.style.display='flex'; });
document.getElementById('howBack').addEventListener('click', ()=> { how.style.display='none'; menu.style.display='flex'; });
document.getElementById('shopBack').addEventListener('click', ()=> { shop.style.display='none'; menu.style.display='flex'; });
document.getElementById('resetBtn').addEventListener('click', ()=> { if (confirm('Reset save? This clears high score, coins, skins and perks.')) { localStorage.removeItem(SAVE_KEY); save = loadSave(); applySaveToUI(); buildShop(); }});
document.getElementById('resumeBtn').addEventListener('click', ()=> togglePause());
document.getElementById('restartBtn').addEventListener('click', ()=> restartRun());
document.getElementById('tryBtn').addEventListener('click', ()=> { restartRun(); document.getElementById('gameOver').style.display='none'; });
document.getElementById('menuBtn').addEventListener('click', ()=> { document.getElementById('gameOver').style.display='none'; menu.style.display='flex'; });

function applySaveToUI(){
  document.getElementById('highScore').textContent = Math.round(save.highScore || 0);
  document.getElementById('savedCoins').textContent = Math.round(save.totalCoins || 0);
  document.getElementById('coinsChip').textContent = 'Coins: ' + ( (save.totalCoins || 0) + coinsCollectedRun );
}

/* ---------------------
   Shop builder
   --------------------- */
function buildShop(){
  const grid = document.getElementById('shopGrid');
  grid.innerHTML = '';
  // skins
  for (const s of SKINS) {
    const card = document.createElement('div'); card.className = 'skinCard';
    const preview = document.createElement('div'); preview.className='skinPreview'; preview.style.background = s.color; preview.textContent = s.name[0];
    const name = document.createElement('div'); name.textContent = s.name; name.style.fontWeight='700';
    const price = document.createElement('div'); price.textContent = s.price === 0 ? 'Free' : s.price + ' coins';
    const btn = document.createElement('button'); btn.className='btn'; btn.style.width='100%';
    const owned = (save.ownedSkins||[]).includes(s.id);
    if (owned) {
      btn.textContent = save.equipped === s.id ? 'Equipped' : 'Equip';
      btn.addEventListener('click', ()=> { save.equipped = s.id; saveGame(); buildShop(); });
    } else {
      btn.textContent = 'Buy';
      btn.addEventListener('click', ()=> {
        if ((save.totalCoins || 0) >= s.price) {
          save.totalCoins = (save.totalCoins || 0) - s.price;
          (save.ownedSkins || (save.ownedSkins = [])).push(s.id);
          save.equipped = s.id;
          saveGame(); applySaveToUI(); buildShop();
        } else alert('Not enough coins');
      });
    }
    card.appendChild(preview); card.appendChild(name); card.appendChild(price); card.appendChild(btn);
    grid.appendChild(card);
  }
  // perks
  for (const p of PERKS) {
    const card = document.createElement('div'); card.className = 'skinCard';
    const name = document.createElement('div'); name.textContent = p.name; name.style.fontWeight='700';
    const price = document.createElement('div'); price.textContent = p.price + ' coins';
    const btn = document.createElement('button'); btn.className='btn alt'; btn.style.width='100%';
    const owned = !!(save.perks && save.perks[p.key]);
    btn.textContent = owned ? 'Owned' : 'Buy';
    btn.addEventListener('click', ()=> {
      if (owned) return;
      if ((save.totalCoins || 0) >= p.price) {
        save.totalCoins = (save.totalCoins || 0) - p.price;
        save.perks = save.perks || {};
        save.perks[p.key] = true;
        saveGame(); applySaveToUI(); buildShop();
        alert(`${p.name} purchased! It will apply automatically in future runs.`);
      } else alert('Not enough coins');
    });
    card.appendChild(name); card.appendChild(price); card.appendChild(btn); grid.appendChild(card);
  }
}

/* ---------------------
   Utility: handle world restart & apply UI initially
   --------------------- */
resetWorld();
applySaveToUI();
buildShop();

/* ensure menu visible initially */
menu.style.display = 'flex';
shop.style.display = 'none';
how.style.display = 'none';
pausePanel.style.display = 'none';
gameOverPanel.style.display = 'none';

</script>
</body>
</html>
